# [12장] 함수
JS에서의 함수에 대해서 한번 알아봅시다! 모든 개념을 다루기 보단 꼭 필요한 개념이나 평소에 잘 몰랐던 개념을 주로 다뤘어요! 정말 기초적인 내용은 생략을 많이 했습니다.
시작할게요! <br><br>

## JS에서의 함수는..
자바스크립트에서의 함수는 `객체` 타입의 값입니다!
```js
var f = function add(a, b){
  return a + b;
};

console.log(f(1, 2)); // 3
```
함수 리터럴 add를 변수 f에 할당하고 f를 호출하는 모습입니다. JS에서는 함수를 변수에 담는게 가능하죠! 함수 리터럴은 평가되어 객체를 반환하고 그 객체의 참조값이 변수 f에
담기는 것입니다.<br><br>

## 함수 선언문과 함수 표현식
+ 함수 선언문에서는 함수 이름을 생략할 수 없습니다.
```js
function (x, y){
  return x + y;
} // ERROR!!
```
+ 함수 표현식에서는 함수 이름을 생략할 수 있습니다.
```js
const f = function (x, y) {return x + y;}; // OK!!
```
+ 함수 선언문은 표현식이 아닌 문입니다. 값으로 평가되지 않는다는 거죠. 하지만 변수에 담기는 것처럼 보입니다.
```js
const f = function add(x, y) {return x + y };
```
왜 그럴까요? 답은 JS 엔진이 관여해서 그렇습니다. JS 엔진은 중의적인 코드의 해석을 코드 문맥에 따라 달리합니다. 위 처럼 함수를 피연산자로 사용했다면 JS는 함수 선언문
이 아니라 함수 리터럴 표현식으로 해석합니다.<br><br>

## 함수 이름은 함수 몸체 내에서만 참조가능한 식별자이다.
> 아닌데요? 함수 이름으로 매번 호출했었는데요? 

저는 매번 함수이름으로 호출했었는데 이게 무슨말일까요?    
```js
// 단독으로 사용했으므로 함수 선언문으로 해석
function foo(a, b){
  return a + b;
}
foo();

// 괄호 연산자의 피연산자로 사용했으므로 함수 리터럴로 해석
(function bar(){}); 
bar(); // ERROR
```
위 말대로라면 bar 함수같은 경우는 이해가 가능합니다. 외부에서 참조 불가능하다 했으니까요. 근데 foo는 왜 외부에서 참조가 가능할까요?
#### JS 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당합니다.
#### 함수 호출은 함수 이름으로 호출하는 것이 아니라 함수 객체를 가르키는 식별자로 호출합니다.
다시 말해 저희가 모르는 사이, JS엔진이 함수 선언문을 읽고 함수 이름과 동일한 이름의 식별자를 하나 만들고 그 식별자는 함수 객체를 가르킨다는 것이군요.<br><br>

## JS에서 함수 다루기
JS의 함수는 `일급 객체`입니다! 즉, 함수를 값처럼 변수에 담거나 프로퍼티의 값이 될 수도 있고 배열의 요소가 될 수도 있습니다. 이 성질은 콜백 함수, 고차 함수를
이해하는데 중요합니다.<br><br>

## 함수 호이스팅
```js
console.log(foo); // f foo(x, y)
console.log(bar); // undefined

function foo(a, b) {
  return a + b
};

var bar = function (x, y){
  return x + y;
}
```
함수 호이스팅이란 `함수 선언문`이 코드의 선두로 끌어 올려진 것처럼 동작하는 JS 고유의 특징입니다. 

변수 호이스팅은 JS 엔진이 런타임 이전에 var로 선언된 변수에 `undefined`를 할당하여 발생하는 것임을 기억하실겁니다.

반면 함수 호이스팅은 JS 엔진이 런타임 이전에 `함수 선언문`에 의해 함수 이름으로 선언된 식별자에 `함수 객체`를 할당하여 발생하는 것입니다. 
즉, 런타임 이전에 함수 객체는 이미 생성된 상태라는 것이죠! 

그렇다면 bar의 경우 `함수 호이스팅`이 일어난 것일까요? `변수 호이스팅`이 일어난 것일까요? 답은 `변수 호이스팅` 입니다! 함수 선언문과 함수 표현식은 엄연히 다른 것이죠.

> 함수가 선언되기 이전에 함수를 호출하는 것은 바람직하지 않습니다. 따라서 함수 선언문 대신 함수 표현식을 사용하는 것을 권장합니다.<br><br>

## JS 함수의 매개변수 특징
1. JS 함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않습니다. 할당되지 않은 매개변수 값은 `undefined` 입니다.
```js
function add(a,b){
  return a + b;
}

add(1); // NaN, 이 경우 b에는 undefined가 들어갑니다.
```
2. JS 함수에서 매개변수보다 초과된 인수는 무시되어 arguments 객체의 프로퍼티로 보관됩니다.<br><br>

## ES6 매개변수 기본값
```js
function add(a = 0, b = 0, c = 0){
  return a + b + c;
}
add(a);
add(a, b);
```
매개변수 기본값은 인수를 전달하지 않았을 때 또는 undefined를 전달했을 때에만 유효합니다!<br><br>

## 참조에 의한 전달, 값에 의한 전달
### `원시 값`은 값에 의한 전달, `객체`는 참조에 의한 전달 방식으로 동작합니다.
이게 무슨말이냐면요.. 아래 코드를 보시죠!
```js
function change(primitive, obj){
  primitive += 100;
  obj.name = "gun"
}
var num = 100;
var person = {name : "Lee"};

change(num, person);

console.log(num); // 100
console.log(person.name) // gun
```
`원시 값`은 값 자체가 복사되어 매개변수에 전달되기 때문에 원본이 훼손되지 않습니다. 즉, 위의 num과 primitive는 값만 같을 뿐 완전 별개의 원시값을 가르키는 
식별자인 거네요!  

다만 `객체`는 참조 값이 복사되어 매개변수에 전달되기 때문에 원본이 훼손될 위험이 있습니다. 즉 `person`은 객체의 주소값을 보관하고 있었고 함수가 호출되어
매개변수 `obj`가 `person`이 담고 있던 주소 값을 복사하고 `obj`를 통해 그 주소를 직접 찾아가 안의 내용을 바꿔버린다는 얘기네요! 이해가 되시나용?<br><br>

## 즉시 실행 함수
```js
var res = (function (a, b){
  return a * b;
}(3, 5));
```
앞서 말했지만 함수 선언문을 피연산자로 사용했다면 함수 리터럴로 해석됩니다. 즉 어떤 값을 평가하여 반환하겠네요!

즉시 실행 함수를 사용할땐 반드시 그룹 연산자 `()`로 감싸줘야 합니다. 안그러면 함수 선언문으로 해석하고 이름이 없다면서 불평할 겁니다.<br><br>

## 콜백 함수
```js
function repeat(n, f){
  for(let i = 0; i < n; i++){ 
    f(i);
  }
}

const logAll = function (i){
  console.log(i);
}

repeat(5, logAll);
```
`콜백 함수`는 함수의 매개변수를 통해 함수의 내부로 전달되는 함수를 말해요! 위 코드에서는 `logAll` 이군요!

`고차 함수`는 매개변수를 통해 함수의 외부에서 콜백 함수를 전달 받은 함수를 말해요! 위 코드에서는 `repeat` 이군요!

용어를 좀 기억을 해주는게 좋은게 책 후반부에 해당 용어가 자주 등장합니다. 

#### 콜백 함수로서 전달된 함수 리터럴은 고차 함수가 호출될 때마다 평가되어 함수 객체가 생성됩니다.
위에서 말했지만, JS 엔진은 암묵적으로 함수 선언문이나 함수 표현식을 만나면 함수 객체를 만든다고 했습니다. 즉 아래 같은 코드를 짜면 위와 같은 비효율적인 
일이 발생한다는 거에요!
```js
  repeat(5, function(i){ console.log(i);});
```
때문에 위 같이 작성하기 보단, 미리 콜백 함수를 어디에 정의해두고 그 함수의 참조를 전달하라는 말이네요!<br><br>

## 순수 함수
+ 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수입니다 (마치 수학에서의 함수 처럼요).
+ 외부 상태를 변경하지 않습니다. (Side Effect가 전혀 없다)<br><br>

## 비순수 함수
+ 외부 상태에 따라 다른 값을 반환할 수 있습니다.
+ 외부 상태를 변경합니다. (Side Effect를 발생시킨다.)

> 비순수 함수보단 가급적 순수 함수를 사용하여 코드의 복잡성을 낮추는 것이 좋습니다.







